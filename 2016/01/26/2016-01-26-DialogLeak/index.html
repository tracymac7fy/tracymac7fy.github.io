<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>2016-01-26-DialogLeak | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写这篇文章之前，先系统介绍下，怎样用MAT追踪项目里面的内存泄漏。  首先，在怀疑项目里面已经发生内存泄漏后，打开AS的Android Device Monitor     选中项目的进程，这里是com.qq.qcloud。接着点击cause GC，提醒系统进行垃圾回收，然后开始dump hprof。这个过程会有点卡，需要等一会儿。这里用as生成hprof之后，还需要用hprof工具转换一下，才能">
<meta property="og:type" content="article">
<meta property="og:title" content="2016-01-26-DialogLeak">
<meta property="og:url" content="http://yoursite.com/2016/01/26/2016-01-26-DialogLeak/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="写这篇文章之前，先系统介绍下，怎样用MAT追踪项目里面的内存泄漏。  首先，在怀疑项目里面已经发生内存泄漏后，打开AS的Android Device Monitor     选中项目的进程，这里是com.qq.qcloud。接着点击cause GC，提醒系统进行垃圾回收，然后开始dump hprof。这个过程会有点卡，需要等一会儿。这里用as生成hprof之后，还需要用hprof工具转换一下，才能">
<meta property="og:image" content="http://yoursite.com/./1453433057801.png">
<meta property="og:image" content="http://yoursite.com/./1453433392760.png">
<meta property="og:image" content="http://yoursite.com/./1453433892965.png">
<meta property="og:image" content="http://yoursite.com/./1453433988179.png">
<meta property="og:image" content="http://yoursite.com/./1453434082524.png">
<meta property="og:image" content="http://yoursite.com/./1453434193258.png">
<meta property="og:image" content="http://yoursite.com/./1453434236024.png">
<meta property="og:updated_time" content="2016-01-26T08:57:40.092Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2016-01-26-DialogLeak">
<meta name="twitter:description" content="写这篇文章之前，先系统介绍下，怎样用MAT追踪项目里面的内存泄漏。  首先，在怀疑项目里面已经发生内存泄漏后，打开AS的Android Device Monitor     选中项目的进程，这里是com.qq.qcloud。接着点击cause GC，提醒系统进行垃圾回收，然后开始dump hprof。这个过程会有点卡，需要等一会儿。这里用as生成hprof之后，还需要用hprof工具转换一下，才能">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2016-01-26-DialogLeak" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/26/2016-01-26-DialogLeak/" class="article-date">
  <time datetime="2016-01-26T08:57:02.000Z" itemprop="datePublished">2016-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      2016-01-26-DialogLeak
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  写这篇文章之前，先系统介绍下，怎样用MAT追踪项目里面的内存泄漏。<br>  首先，在怀疑项目里面已经发生内存泄漏后，打开AS的Android Device Monitor<br>  <img src="/./1453433057801.png" alt="Alt text"><br>   选中项目的进程，这里是com.qq.qcloud。接着点击cause GC，提醒系统进行垃圾回收，然后开始dump hprof。这个过程会有点卡，需要等一会儿。这里用as生成hprof之后，还需要用hprof工具转换一下，才能用MAT打开：<br>   <img src="/./1453433392760.png" alt="Alt text"><br>   在tools工具下输入下面的命令进行转换，然后就可以直接用MAT打开这个hprof文件了。<br>   <img src="/./1453433892965.png" alt="Alt text"><br>    MAT里面用的最多最实用的就是直方图（Histogram）了，点击<img src="/./1453433988179.png" alt="Alt text"><br>这个按钮，进入直方图界面，这里列举了还在堆内存里面的对象，我们可以很方便的搜索某一个类，看看这个类的对象是否还在堆内存里面，以便我们知道是否发生了leak：<br><img src="/./1453434082524.png" alt="Alt text"><br> 如上图，这个PickerActivity已经不在前台，但是仍然有引用链，说明这个Activity发生了内存泄漏。要查看具体的引用链，我们可以去除掉软引弱引，看看是否还存在引用：<br> <img src="/./1453434193258.png" alt="Alt text"><br>  如下图，真正的引用链还存在，说明这个Activity确实发生了内存泄漏，并且最终是在一个handlerthread被引用。<br>  <img src="/./1453434236024.png" alt="Alt text"></p>
<p>  ##Dialog</p>
<p>  ###起因<br>   事情是这样的，开发清理模块的时候发现leakcanary老是给我弹toast提示我内存泄漏，用MAT追踪了一下发现引用链大概如上图，有一个loadingdialog对象（间接）持有了Activity对象，而这个loadingdialog对象一直被一个handlerThread持有。一开始查看代码并没有发现什么问题，而且这个非亲非故的handerthread跟我的业务代码半毛钱关系没有，不知道是从哪里冒出来持有了我的loadingdialog。问题搁浅了几天，直到看到了以下这两篇文章，才明白了这个泄漏的根源：<br>  <a href="http://km.oa.com/group/11800/articles/show/252965?kmref=search&amp;from_page=1&amp;no=1&amp;is_from_iso=1" target="_blank" rel="external">http://km.oa.com/group/11800/articles/show/252965?kmref=search&amp;from_page=1&amp;no=1&amp;is_from_iso=1</a><br>  <a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-25/%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88-Square.md" target="_blank" rel="external">https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-25/%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88-Square.md</a><br>  这两篇文章的作者遇到的问题跟我如出一辙，dialog莫名其妙的引发Activity泄漏！</p>
<p>  ###为什么<br>  先说结论：<br>  在API level 21以下使用Android官方提供并且推荐的DialogFragment有很大可能引发内存泄漏！</p>
<p>  ####Message原理<br>  了解这个问题之前，要先了解一下Android的Handler/Looper/Message机制，looper里面的message循环代码原理大概是这样的：<br>  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    msg.<span class="keyword">target</span>.dispatchMessage(msg);</span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  首先从messagequeue中取出一条msg，这里是阻塞的，也就是说一直等待下一条msg到来（HandlerThread的原理），拿到msg之后，dispatchMessage开始处理这条msg，该干啥干啥，搞完之后执行recycle：<br> <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">  * Recycles a Message that may be in-use.</span><br><span class="line">  * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span><br><span class="line">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">     <span class="comment">// Clear out all other details.</span></span><br><span class="line">     flags = FLAG_IN_USE;</span><br><span class="line">     what = <span class="number">0</span>;</span><br><span class="line">     arg1 = <span class="number">0</span>;</span><br><span class="line">     arg2 = <span class="number">0</span>;</span><br><span class="line">     obj = <span class="keyword">null</span>;</span><br><span class="line">     replyTo = <span class="keyword">null</span>;</span><br><span class="line">     sendingUid = -<span class="number">1</span>;</span><br><span class="line">     when = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">target</span> = <span class="keyword">null</span>;</span><br><span class="line">     callback = <span class="keyword">null</span>;</span><br><span class="line">     data = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">         <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">             next = sPool;</span><br><span class="line">             sPool = <span class="keyword">this</span>;</span><br><span class="line">             sPoolSize++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>  recycle这一步就是把msg里面的东西都置空，放进msg池里面（msg池实际上是个链表），别人需要生成一条msg，obtainMessage的时候，就会优先从池子里面去捞出来这些msg复用。这里有个问题需要注意，msg池是所有线程共享的，也就是说，这个线程回收了一个msg，别的线程有可能拿去填充并且复用！这里就有问题了，我们回头看看这里：<br>    <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    msg.<span class="keyword">target</span>.dispatchMessage(msg);</span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  别的线程，如HandlerThread执行的时候，用完了一条msg，把这条msg置空放进回收池，然后等待下一条msg到来，这个时候是阻塞的，也就是说，下一条消息到来之前，这个线程<strong>会一直持有一个空的msg</strong>，这条msg实际上是在msg池子里面的，别的线程有可能拿去复用。这也算是davik的一个bug吧，理论上这条msg已经结束循环了，不应该继续持有才对。这个bug，上面提到的那篇<a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-25/%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88-Square.md" target="_blank" rel="external">文章</a> 有详细说明<br>  不过仔细想想，这好像也没有什么问题，因为msg用完都是会recycle的，recycle会把msg所有东西置空，理论上，别的线程就算拿着这个被持有的空的msg去用，用完也会recycle，并不会引发Activity内存泄漏啊。这个时候，我们就需要追踪这个可恶的dialog，看看它到底做了什么事情！</p>
<p>  ####Dialog的bug<br>  事情是这样的，我们看看Dialog的源码。<br>    dialog的显示取消关闭都是通过msg机制来发消息做的，以dismiss为例，可以看到这里发送一条dismissMsg来进行dismiss，不过等等。。。这个mDismissMessage是从哪里来的。。。<br>    <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">sendDismissMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (mDismissMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// Obtain a new message so this dialog can be re-used</span></span><br><span class="line">         Message.obtain(mDismissMessage).sendToTarget();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> 不过等等。。。这个mDismissMessage是从哪里来的。。。我们再看看这个代码：<br>  <figure class="highlight"><figcaption><span>void setOnDismissListener(final OnDismissListener listener) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    if (mCancelAndDismissTaken != null) &#123;&#10;        throw new IllegalStateException(&#10;                &#34;OnDismissListener is already taken by &#34;&#10;                + mCancelAndDismissTaken + &#34; and can not be replaced.&#34;);&#10;    &#125;&#10;    if (listener != null) &#123;&#10;        mDismissMessage = mListenersHandler.obtainMessage(DISMISS, listener);&#10;    &#125; else &#123;&#10;        mDismissMessage = null;&#10;    &#125;&#10;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p> 这个方法个给Dialog设置了一个litener，并且用把这个listener设置给了这个msg的obj。重点来了，不知道各位注意到没有，Dialog的mDismissMessage是个自己持有的成员变量，并且，<strong>每次发送消息的时候都是采用obtain的方式复制一个msg然后发送出去，也就是说，这个自己持有的msg从来没有被发送出去，也就从来没有被recycle！</strong><br>  这个就有问题了，dialog自己持有了msg，而且还不发送出去，而且还把listerner穿给msg的obj（这个listener极大可能是个Activity或者fragment，如果直接采用implement方式继承这个listener接口的话）<br>  n条罪名，真想把它拖出去墙壁5分钟！</p>
<p>  ####DialogFragment<br>  我们再来看看DialogFragment做了什么事情</p>
<pre><code>@Override
public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    ....
    mDialog.setOnCancelListener(this);
    mDialog.setOnDismissListener(this);
    ...
}
</code></pre><p>  中间省略了一些代码，我们可以看到，DialogFragment果然把自己当作listener穿给了Dialog，这就引发了内存泄漏！</p>
<p>   ####结论<br>   这里做一下定论，这个Dialog引发的内存泄漏的原因是：<br>   Fragment（或者Activity）把自己当作listener传给了Dialog，而Dialog把这个listener设置给了mseeage的obj，并且一直没有发送这个msg，作为自己持有。如果这个msg在obtain的时候，是拿的别的线程recycle在消息池里面的msg，那么这个msg就会一直被别的线程持有，导致内存泄漏！</p>
<p>   ###解决方案<br>   这里我采用了一个重写DialogFragment的解决方案，给Dialog传weakListener，可行性有待验证<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WyDialogFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">      ....</span><br><span class="line">      mDialog.setOnCancelListener(<span class="keyword">new</span> WeakOncancelListener(<span class="keyword">this</span>));</span><br><span class="line">      mDialog.setOnDismissListener(<span class="keyword">new</span> WeakOndismissListener(<span class="keyword">this</span>));</span><br><span class="line">     ....</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakOndismissListener</span> <span class="keyword">implements</span> <span class="title">DialogInterface</span>.<span class="title">OnDismissListener</span></span>&#123;</span><br><span class="line">      WeakReference&lt;WyDialogFragment&gt; reference;</span><br><span class="line">      WeakOndismissListener(WyDialogFragment fragment)&#123;</span><br><span class="line">          reference = <span class="keyword">new</span> WeakReference&lt;WyDialogFragment&gt;(fragment);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="annotation">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDismiss</span><span class="params">(DialogInterface dialog)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> WyDialogFragment fragment = reference.get();</span><br><span class="line">          <span class="keyword">if</span>(fragment != <span class="keyword">null</span>)&#123;</span><br><span class="line">              fragment.onDismiss(dialog);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>   这里复制了原生DialogFragment的代码，大部分没有变动，只是做了一个weakListener，给Dialog传weakListener，而不是fragment或者Activity自己，解决了这个问题!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/26/2016-01-26-DialogLeak/" data-id="cijv66yf100005orx0ytulvmu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/01/26/2016-01-26-DialogLeak/">2016-01-26-DialogLeak</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>